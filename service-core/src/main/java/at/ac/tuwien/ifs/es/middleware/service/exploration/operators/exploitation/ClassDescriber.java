package at.ac.tuwien.ifs.es.middleware.service.exploration.operators.exploitation;

import at.ac.tuwien.ifs.es.middleware.common.exploration.context.resources.ResourceCollection;
import at.ac.tuwien.ifs.es.middleware.common.exploration.context.result.Resource;
import at.ac.tuwien.ifs.es.middleware.sparql.result.SelectQueryResult;
import at.ac.tuwien.ifs.es.middleware.common.exploration.context.util.result.RDFTermJsonUtil;
import at.ac.tuwien.ifs.es.middleware.service.analysis.dataset.classes.hierarchy.ClassHierarchyService;
import at.ac.tuwien.ifs.es.middleware.service.exploration.operators.payload.VoidPayload;
import at.ac.tuwien.ifs.es.middleware.common.exploration.RegisterForExplorationFlow;
import at.ac.tuwien.ifs.es.middleware.common.knowledgegraph.SPARQLService;
import com.fasterxml.jackson.core.JsonPointer;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.JsonNodeFactory;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.stream.Collectors;
import org.apache.commons.lang.text.StrSubstitutor;
import org.apache.commons.rdf.api.BlankNodeOrIRI;
import org.apache.commons.rdf.api.RDFTerm;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Component;

@Lazy
@Component
@RegisterForExplorationFlow(ClassDescriber.OID)
public class ClassDescriber implements
    ExploitationOperator<ResourceCollection, ResourceCollection, VoidPayload> {

  public static final String OID = "esm.exploit.class.info";

  private static final String CLASS_QUERY = "SELECT ?resource ?class {\n"
      + "    VALUES ?resource {\n"
      + "        ${resourceList}\n"
      + "    }\n"
      + "    ?resource a ?class .\n"
      + "    FILTER(isIRI(?class)) .\n"
      + "}";

  private static final int LOAD_SIZE = 10000;

  private final SPARQLService sparqlService;
  private final ClassHierarchyService classHierarchyService;

  @Autowired
  public ClassDescriber(SPARQLService sparqlService, ClassHierarchyService classHierarchyService) {
    this.sparqlService = sparqlService;
    this.classHierarchyService = classHierarchyService;
  }

  @Override
  public String getUID() {
    return OID;
  }

  @Override
  public Class<ResourceCollection> getExplorationContextInputClass() {
    return ResourceCollection.class;
  }

  @Override
  public Class<ResourceCollection> getExplorationContextOutputClass() {
    return ResourceCollection.class;
  }

  @Override
  public Class<VoidPayload> getPayloadClass() {
    return VoidPayload.class;
  }

  @Override
  public ResourceCollection apply(ResourceCollection context, VoidPayload payload) {
    List<Resource> allResources = new ArrayList<>(context.asResourceSet());
    /* gather class info */
    Map<Resource, Set<Resource>> classMap = new HashMap<>();
    int total = allResources.size();
    int totalCalls = (int) Math.ceil((double) total / LOAD_SIZE);
    for (int n = 0; n < totalCalls; n++) {
      int start = n * LOAD_SIZE;
      int end = start + LOAD_SIZE;
      List<Map<String, RDFTerm>> resourceClassResponse = sparqlService.<SelectQueryResult>query(
          new StrSubstitutor(
              Collections.singletonMap("resourceList",
                  allResources.subList(start, end <= total ? end : total).stream().map(
                      RDFTermJsonUtil::stringForSPARQLResourceOf)
                      .collect(Collectors.joining("\n"))))
              .replace(CLASS_QUERY), true).value();
      for (Map<String, RDFTerm> row : resourceClassResponse) {
        Resource resource = new Resource((BlankNodeOrIRI) row.get("resource"));
        Set<Resource> classList = classMap.get(resource);
        if (classList == null) {
          classList = new HashSet<>();
          classMap.put(resource, classList);
        }
        classList.add(new Resource((BlankNodeOrIRI) row.get("class")));
      }
    }
    /* store the class info in the context */
    JsonPointer allClassInfoPointer = JsonPointer.compile("/classInfo/all");
    JsonPointer specificClassInfoPointer = JsonPointer.compile("/classInfo/specific");
    for (Entry<Resource, Set<Resource>> entry : classMap.entrySet()) {
      /* all classes */
      ArrayNode allClassArrayNode = JsonNodeFactory.instance.arrayNode();
      for (Resource classResource : classHierarchyService.getAllClasses(entry.getValue())) {
        allClassArrayNode.add(classResource.getId());
      }
      context.values().put(entry.getKey().getId(), allClassInfoPointer, allClassArrayNode);
      /* most specific classes */
      ArrayNode specificClassArrayNode = JsonNodeFactory.instance.arrayNode();
      for (Resource classResource : classHierarchyService
          .getMostSpecificClasses(entry.getValue())) {
        specificClassArrayNode.add(classResource.getId());
      }
      context.values().put(entry.getKey().getId(), specificClassInfoPointer,
          specificClassArrayNode);
    }
    return context;
  }
}
