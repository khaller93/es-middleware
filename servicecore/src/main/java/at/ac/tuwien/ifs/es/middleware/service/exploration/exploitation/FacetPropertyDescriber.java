package at.ac.tuwien.ifs.es.middleware.service.exploration.exploitation;

import at.ac.tuwien.ifs.es.middleware.dto.exploration.context.ExplorationContext;
import at.ac.tuwien.ifs.es.middleware.dto.exploration.context.IterableResourcesContext;
import at.ac.tuwien.ifs.es.middleware.dto.exploration.util.BlankOrIRIJsonUtil;
import at.ac.tuwien.ifs.es.middleware.dto.sparql.SelectQueryResult;
import at.ac.tuwien.ifs.es.middleware.service.exception.ExplorationFlowSpecificationException;
import at.ac.tuwien.ifs.es.middleware.service.exploration.payload.FacetPropertyPayload;
import at.ac.tuwien.ifs.es.middleware.service.exploration.registry.RegisterForExplorationFlow;
import at.ac.tuwien.ifs.es.middleware.service.knowledgegraph.sparql.SPARQLService;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.JsonNodeFactory;
import com.fasterxml.jackson.databind.node.ObjectNode;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.stream.Collectors;
import org.apache.commons.lang.text.StrSubstitutor;
import org.apache.commons.rdf.api.BlankNodeOrIRI;
import org.apache.commons.rdf.api.Literal;
import org.apache.commons.rdf.api.RDFTerm;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Component;

/**
 * @author Kevin Haller
 * @version 1.0
 * @since 1.0
 */
@Lazy
@Component
@RegisterForExplorationFlow("esm.exploit.facet.property")
public class FacetPropertyDescriber implements ExploitationOperator<FacetPropertyPayload> {

  private static final Logger logger = LoggerFactory.getLogger(FacetPropertyDescriber.class);

  private static final String FACET_PROP_QUERY =
      "SELECT ?p ?v (count(DISTINCT ?s) as ?cnt) WHERE {\n"
          + "    VALUES ?s {\n"
          + "       ${resourceList} \n"
          + "    }\n"
          + "    VALUES ?p {\n"
          + "       ${propertyList} \n"
          + "    }\n"
          + "    ?s ?p ?v .\n"
          + "    FILTER(isIRI(?v) || isLiteral(?v))\n"
          + "} GROUP BY ?p ?v";

  private final SPARQLService sparqlService;
  private final ObjectMapper objectMapper;

  @Autowired
  public FacetPropertyDescriber(SPARQLService sparqlService, ObjectMapper objectMapper) {
    this.sparqlService = sparqlService;
    this.objectMapper = objectMapper;
  }

  @Override
  public Class<FacetPropertyPayload> getParameterClass() {
    return FacetPropertyPayload.class;
  }

  @Override
  public ExplorationContext apply(ExplorationContext context, FacetPropertyPayload payload) {
    logger.debug("A facet description of resources {} has been requested with {}.", payload,
        context);
    if (context instanceof IterableResourcesContext) {
      Map<String, String> valueMap = new HashMap<>();
      valueMap
          .put("resourceList", ((IterableResourcesContext) context).asResourceSet().stream().map(
              BlankOrIRIJsonUtil::stringForSPARQLResourceOf).collect(Collectors.joining("\n")));
      valueMap
          .put("propertyList", payload.getProperties().stream().map(
              BlankOrIRIJsonUtil::stringForSPARQLResourceOf).collect(Collectors.joining("\n")));
      List<Map<String, RDFTerm>> result = sparqlService.<SelectQueryResult>query(
          new StrSubstitutor(valueMap).replace(FACET_PROP_QUERY),
          true).value();
      /* process the result */
      Map<String, ArrayNode> facetMap = new HashMap<>();
      for (Map<String, RDFTerm> row : result) {
        ArrayNode propertyValueArrayNode = facetMap
            .compute(BlankOrIRIJsonUtil.stringValue((BlankNodeOrIRI) row.get("p")),
                (s, propertyNode1) -> propertyNode1 != null ? propertyNode1
                    : JsonNodeFactory.instance.arrayNode());
        /* create value node for the rdf term (literal or IRI) */
        ObjectNode valueNode = JsonNodeFactory.instance.objectNode();
        RDFTerm valueTerm = row.get("v");
        Integer totalNumber = Integer.parseInt(((Literal) row.get("cnt")).getLexicalForm());
        if (valueTerm instanceof Literal) {
          valueNode.set("type", JsonNodeFactory.instance.textNode("literal"));
          valueNode.set("literal", objectMapper.valueToTree(valueTerm));
          valueNode.set("total", JsonNodeFactory.instance.numberNode(totalNumber));
        } else {
          valueNode.set("type", JsonNodeFactory.instance.textNode("iri"));
          valueNode.set("iri", objectMapper.valueToTree(valueTerm));
          valueNode.set("total", JsonNodeFactory.instance.numberNode(totalNumber));
        }
        propertyValueArrayNode.add(valueNode);
      }
      /* add processed result to context */
      ObjectNode facetNode = JsonNodeFactory.instance.objectNode();
      for (Entry<String, ArrayNode> valueArrayEntry : facetMap.entrySet()) {
        facetNode.set(valueArrayEntry.getKey(), valueArrayEntry.getValue());
      }
      context.setMetadataFor("facet", facetNode);
      return context;
    } else {
      throw new ExplorationFlowSpecificationException(
          "The given exploration flow is not valid, because a facet property describer needs a context with an iterable collection of resources.");
    }
  }
}
