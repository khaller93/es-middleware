package at.ac.tuwien.ifs.es.middleware.service.exploration.exploitation;

import at.ac.tuwien.ifs.es.middleware.dto.exploration.context.ExplorationContext;
import at.ac.tuwien.ifs.es.middleware.dto.exploration.context.IterableResourcesContext;
import at.ac.tuwien.ifs.es.middleware.dto.exploration.context.result.Resource;
import at.ac.tuwien.ifs.es.middleware.dto.exploration.util.BlankOrIRIJsonUtil;
import at.ac.tuwien.ifs.es.middleware.dto.sparql.SelectQueryResult;
import at.ac.tuwien.ifs.es.middleware.service.analysis.dataset.classes.hierarchy.ClassHierarchyService;
import at.ac.tuwien.ifs.es.middleware.service.exception.ExplorationFlowSpecificationException;
import at.ac.tuwien.ifs.es.middleware.service.exploration.payload.VoidPayload;
import at.ac.tuwien.ifs.es.middleware.service.exploration.registry.RegisterForExplorationFlow;
import at.ac.tuwien.ifs.es.middleware.service.knowledgegraph.sparql.SPARQLService;
import com.fasterxml.jackson.core.JsonPointer;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.JsonNodeFactory;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.stream.Collectors;
import org.apache.commons.lang.text.StrSubstitutor;
import org.apache.commons.rdf.api.BlankNodeOrIRI;
import org.apache.commons.rdf.api.RDFTerm;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Component;

@Lazy
@Component
@RegisterForExplorationFlow("esm.exploit.class.info")
public class ClassDescriber implements ExploitationOperator<VoidPayload> {

  private static final Logger logger = LoggerFactory.getLogger(ClassDescriber.class);

  private static final String CLASS_QUERY = "SELECT ?resource ?class {\n"
      + "    VALUES ?resource {\n"
      + "        ${resourceList}\n"
      + "    }\n"
      + "    ?resource a ?class .\n"
      + "    FILTER(isIRI(?class)) .\n"
      + "}";

  private static final int LOAD_SIZE = 10000;

  private final SPARQLService sparqlService;
  private final ClassHierarchyService classHierarchyService;

  @Autowired
  public ClassDescriber(SPARQLService sparqlService, ClassHierarchyService classHierarchyService) {
    this.sparqlService = sparqlService;
    this.classHierarchyService = classHierarchyService;
  }

  @Override
  public Class<VoidPayload> getParameterClass() {
    return VoidPayload.class;
  }

  @Override
  public ExplorationContext apply(ExplorationContext context, VoidPayload payload) {
    if (context instanceof IterableResourcesContext) {
      List<Resource> allResources = new ArrayList<>(
          ((IterableResourcesContext) context).asResourceSet());
      /* gather class info */
      Map<Resource, Set<Resource>> classMap = new HashMap<>();
      int total = allResources.size();
      int totalCalls = (int) Math.ceil((double) total / LOAD_SIZE);
      for (int n = 0; n < totalCalls; n++) {
        int start = n * LOAD_SIZE;
        int end = start + LOAD_SIZE;
        List<Map<String, RDFTerm>> resourceClassResponse = sparqlService.<SelectQueryResult>query(
            new StrSubstitutor(
                Collections.singletonMap("resourceList",
                    allResources.subList(start, end <= total ? end : total).stream().map(
                        BlankOrIRIJsonUtil::stringForSPARQLResourceOf)
                        .collect(Collectors.joining("\n"))))
                .replace(CLASS_QUERY), true).value();
        for (Map<String, RDFTerm> row : resourceClassResponse) {
          Resource resource = new Resource((BlankNodeOrIRI) row.get("resource"));
          Set<Resource> classList = classMap.get(resource);
          if (classList == null) {
            classList = new HashSet<>();
            classMap.put(resource, classList);
          }
          classList.add(new Resource((BlankNodeOrIRI) row.get("class")));
        }
      }
      /* store the class info in the context */
      JsonPointer allClassInfoPointer = JsonPointer.compile("/classInfo/all");
      JsonPointer specificClassInfoPointer = JsonPointer.compile("/classInfo/specific");
      for (Entry<Resource, Set<Resource>> entry : classMap.entrySet()) {
        /* all classes */
        ArrayNode allClassArrayNode = JsonNodeFactory.instance.arrayNode();
        for (Resource classResource : classHierarchyService.getAllClasses(entry.getValue())) {
          allClassArrayNode.add(classResource.getId());
        }
        context.putValuesData(entry.getKey().getId(), allClassInfoPointer, allClassArrayNode);
        /* most specific classes */
        ArrayNode specificClassArrayNode = JsonNodeFactory.instance.arrayNode();
        for (Resource classResource : classHierarchyService
            .getMostSpecificClasses(entry.getValue())) {
          specificClassArrayNode.add(classResource.getId());
        }
        context.putValuesData(entry.getKey().getId(), specificClassInfoPointer,
            specificClassArrayNode);
      }
      return context;
    } else {
      throw new ExplorationFlowSpecificationException(
          "The given exploration flow is not valid, because a class describer needs a context with an iterable collection of resources.");
    }
  }
}
