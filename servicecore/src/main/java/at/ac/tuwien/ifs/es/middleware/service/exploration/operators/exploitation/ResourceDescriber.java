package at.ac.tuwien.ifs.es.middleware.service.exploration.operators.exploitation;

import at.ac.tuwien.ifs.es.middleware.dto.exploration.context.IterableResourcesContext;
import at.ac.tuwien.ifs.es.middleware.dto.exploration.context.ResourceCollection;
import at.ac.tuwien.ifs.es.middleware.dto.exploration.context.result.Resource;
import at.ac.tuwien.ifs.es.middleware.service.exploration.operators.payload.exploitation.DescriberPayload.PropertyPayload;
import at.ac.tuwien.ifs.es.middleware.service.exploration.operators.payload.exploitation.DescriberPayload.TextLiteralPayload;
import at.ac.tuwien.ifs.es.middleware.dto.exploration.util.BlankOrIRIJsonUtil;
import at.ac.tuwien.ifs.es.middleware.dto.sparql.SelectQueryResult;
import at.ac.tuwien.ifs.es.middleware.service.exception.ExplorationFlowSpecificationException;
import at.ac.tuwien.ifs.es.middleware.service.exploration.operators.payload.exploitation.DescriberPayload;
import at.ac.tuwien.ifs.es.middleware.service.exploration.registry.ExplorationFlowRegistry;
import at.ac.tuwien.ifs.es.middleware.service.exploration.registry.RegisterForExplorationFlow;
import at.ac.tuwien.ifs.es.middleware.service.knowledgegraph.sparql.SPARQLService;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.JsonNodeFactory;
import com.fasterxml.jackson.databind.node.ObjectNode;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.stream.Collectors;
import org.apache.commons.rdf.api.BlankNodeOrIRI;
import org.apache.commons.rdf.api.IRI;
import org.apache.commons.rdf.api.Literal;
import org.apache.commons.rdf.api.RDFTerm;
import org.apache.commons.text.StringSubstitutor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Component;

/**
 * This exploitation operation can be used to get the description get resources in a {@link
 * IterableResourcesContext}. If another context is passed, this operation cannot be executed and a
 * {@link ExplorationFlowSpecificationException} will be thrown. It will be registered at {@link
 * ExplorationFlowRegistry} under the name {@code esm.exploit.describe}.
 * <p/>
 * This operator expects {@link DescriberPayload} as argument for the execution, whereas this
 * payload can be empty, or specify the content that shall be returned. Each content has a name, a
 * type and list get properties that hold this content. e.g. content might be {@code 'label'}, which
 * is get type {@code text} and has the property list {@code ["http://www.w3.org/2000/01/rdf-schema#label"]}.
 *
 * @author Kevin Haller
 * @version 1.0
 * @since 1.0
 */
@Lazy
@Component
@RegisterForExplorationFlow("esm.exploit.describe")
public class ResourceDescriber implements
    ExploitationOperator<IterableResourcesContext, IterableResourcesContext, DescriberPayload> {

  private static final Logger logger = LoggerFactory.getLogger(ResourceDescriber.class);

  private static final String DESCRIBER_QUERY = "SELECT ?s ${contentVars} WHERE { \n"
      + "VALUES ?s {\n"
      + "  ${resourceList}\n"
      + "}\n"
      + "${content}\n"
      + "}";

  private static final String CONTENT_SECTION_SUB_QUERY =
      "OPTIONAL {\n"
          + "%s\n"
          + "%s\n"
          + "}";

  private SPARQLService sparqlService;


  public ResourceDescriber(@Autowired SPARQLService sparqlService) {
    this.sparqlService = sparqlService;
  }

  @Override
  public String getUID() {
    return "esm.exploit.describe";
  }

  @Override
  public Class<IterableResourcesContext> getExplorationContextInputClass() {
    return IterableResourcesContext.class;
  }

  @Override
  public Class<IterableResourcesContext> getExplorationContextOutputClass() {
    return IterableResourcesContext.class;
  }

  @Override
  public Class<DescriberPayload> getPayloadClass() {
    return DescriberPayload.class;
  }

  /**
   * Computes the 'describe' query for the given {@code resourceSet} considering given {@code
   * payload} specifying the arguments for this step.
   *
   * @param resourceSet a set get {@link Resource}s that shall be described.
   * @param payload specifying the arguments for the describer.
   * @return the computed 'describe' query.
   */
  private String computeDescribeQuery(Set<Resource> resourceSet, DescriberPayload payload) {
    Map<String, String> valueMap = new HashMap<>();
    valueMap.put("resourceList", resourceSet.stream().map(
        BlankOrIRIJsonUtil::stringForSPARQLResourceOf).collect(Collectors.joining("\n")));
    Map<String, PropertyPayload> content = payload.getContent();
    valueMap.put("contentVars",
        content.keySet().stream().map(p -> "?" + p).collect(Collectors.joining(" ")));
    valueMap.put("content",
        content.entrySet().stream().map(e -> prepareContentSection(e.getKey(), e.getValue()))
            .collect(Collectors.joining("\n")));
    return new StringSubstitutor(valueMap).replace(DESCRIBER_QUERY);
  }

  /**
   * Prepares the section get the SPARQL query that should match the specified content. It is
   * assumed, that there might be not content and the pattern matching is embedded into {@code
   * OPTIONAL}.
   *
   * @param name the name get the content section e.g. label, description, thumbnail.
   * @param propertyPayload that specifies the details for the content.
   * @return a SPARQL section that can be inserted into the description query.
   */
  private String prepareContentSection(String name, PropertyPayload propertyPayload) {
    if (propertyPayload.getProperties().isEmpty()) {
      return "";
    }
    List<String> resourceSets = propertyPayload.getProperties().stream().map(
        p -> String.format("{ ?s %s ?%s }", BlankOrIRIJsonUtil.stringForSPARQLResourceOf(p), name))
        .collect(Collectors.toList());
    Iterator<String> propIterator = resourceSets.iterator();
    StringBuilder resourceSetsSPARQL = new StringBuilder(propIterator.next());
    while (propIterator.hasNext()) {
      resourceSetsSPARQL.append(" UNION ").append(propIterator.next());
    }
    StringBuilder languageFilter = new StringBuilder("");
    if (propertyPayload instanceof TextLiteralPayload) {
      List<String> languages = ((TextLiteralPayload) propertyPayload).getLanguages();
      if (!languages.isEmpty()) {
        languageFilter.append("FILTER(");
        Iterator<String> languageIterator = languages.iterator();
        languageFilter.append(
            String.format("lang(?%s) = '%s'", name, mapLanguageName(languageIterator.next())));
        while (languageIterator.hasNext()) {
          languageFilter.append(" || ")
              .append(String
                  .format("lang(?%s) = '%s'", name, mapLanguageName(languageIterator.next())));
        }
        languageFilter.append(")");
      }
    }
    return String.format(CONTENT_SECTION_SUB_QUERY, resourceSetsSPARQL.toString(),
        languageFilter.toString());
  }

  private String mapLanguageName(String name) {
    return "default".equals(name) ? "" : name;
  }

  @Override
  public IterableResourcesContext apply(IterableResourcesContext context, DescriberPayload payload) {
    List<Map<String, RDFTerm>> resultTable = (sparqlService.<SelectQueryResult>query(
        computeDescribeQuery(context.asResourceSet(), payload),
        false)).value();
    Map<String, Map<String, DescribeTerm>> responseMap = new HashMap<>();
    for (Map<String, RDFTerm> row : resultTable) {
      Map<String, DescribeTerm> contentMap = responseMap
          .computeIfAbsent(((IRI) (row.get("s"))).getIRIString(), k -> new HashMap<>());
      for (String col : row.keySet()) {
        if (!"s".equals(col)) {
          RDFTerm term = row.get(col);
          if (term instanceof Literal) {
            Literal literal = (Literal) term;
            ((TextValue) contentMap.computeIfAbsent(col, k -> new TextValue()))
                .add(literal.getLanguageTag().orElse("default"), literal.getLexicalForm());
          } else {
            ((IRIValue) contentMap.computeIfAbsent(col, k -> new IRIValue()))
                .add(BlankOrIRIJsonUtil.stringValue((BlankNodeOrIRI) term));
          }
        }
      }
    }
    for (Entry<String, Map<String, DescribeTerm>> entry : responseMap.entrySet()) {
      for (Entry<String, DescribeTerm> contentEntry : entry.getValue().entrySet()) {
        context.putValuesData(entry.getKey(), Arrays.asList("describe", contentEntry.getKey()),
            contentEntry.getValue().toJson());
      }
    }
    return context;
  }

  public interface DescribeTerm {

    JsonNode toJson();

  }

  public static final class IRIValue implements DescribeTerm {

    private Set<String> values = new HashSet<>();

    public void add(String value) {
      this.values.add(value);
    }

    public Set<String> getValues() {
      return values;
    }

    @Override
    public JsonNode toJson() {
      ArrayNode array = JsonNodeFactory.instance.arrayNode();
      for (String v : values) {
        array.add(v);
      }
      ObjectNode objNode = JsonNodeFactory.instance.objectNode();
      objNode.set("values", array);
      objNode.put("@type", "iri");
      return objNode;
    }
  }

  public static final class TextValue implements DescribeTerm {

    private Map<String, Set<String>> values = new HashMap<>();

    public void add(String language, String value) {
      values.computeIfAbsent(language, k -> new HashSet<>()).add(value);
    }

    public Map<String, Set<String>> getValues() {
      return values;
    }

    @Override
    public JsonNode toJson() {
      ObjectNode valObject = JsonNodeFactory.instance.objectNode();
      for (String language : values.keySet()) {
        Set<String> vals = values.get(language);
        if (vals != null && !vals.isEmpty()) {
          ArrayNode array = JsonNodeFactory.instance.arrayNode();
          for (String v : vals) {
            array.add(v);
          }
          valObject.set(language, array);
        }
      }
      ObjectNode objNode = JsonNodeFactory.instance.objectNode();
      objNode.set("values", valObject);
      objNode.put("@type", "text");
      return objNode;
    }
  }

}
