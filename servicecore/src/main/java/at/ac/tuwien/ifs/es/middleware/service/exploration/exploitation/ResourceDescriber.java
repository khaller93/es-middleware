package at.ac.tuwien.ifs.es.middleware.service.exploration.exploitation;

import at.ac.tuwien.ifs.es.middleware.dto.exploration.context.ExplorationContext;
import at.ac.tuwien.ifs.es.middleware.dto.exploration.context.IterableResourcesContext;
import at.ac.tuwien.ifs.es.middleware.dto.exploration.context.result.Resource;
import at.ac.tuwien.ifs.es.middleware.dto.exploration.payload.exploitation.DescriberPayload.DescribePropertyPayload;
import at.ac.tuwien.ifs.es.middleware.dto.exploration.util.BlankOrIRIJsonUtil;
import at.ac.tuwien.ifs.es.middleware.dto.sparql.SelectQueryResult;
import at.ac.tuwien.ifs.es.middleware.service.exception.ExplorationFlowSpecificationException;
import at.ac.tuwien.ifs.es.middleware.dto.exploration.payload.exploitation.DescriberPayload;
import at.ac.tuwien.ifs.es.middleware.service.exploration.registry.ExplorationFlowRegistry;
import at.ac.tuwien.ifs.es.middleware.service.exploration.registry.RegisterForExplorationFlow;
import at.ac.tuwien.ifs.es.middleware.service.sparql.SPARQLService;
import com.fasterxml.jackson.databind.node.JsonNodeFactory;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.google.common.collect.Table;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import org.apache.commons.rdf.api.BlankNodeOrIRI;
import org.apache.commons.rdf.api.IRI;
import org.apache.commons.rdf.api.Literal;
import org.apache.commons.rdf.api.RDFTerm;
import org.apache.logging.log4j.core.lookup.StrSubstitutor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Component;

/**
 * This exploitation operation can be used to get the description of resources in a {@link
 * IterableResourcesContext}. If another context is passed, this operation cannot be executed and a
 * {@link ExplorationFlowSpecificationException} will be thrown. It will be registered at {@link
 * ExplorationFlowRegistry} under the name {@code esm.exploit.describe}.
 * <p/>
 * Per default the label ({@code rdfs:label}) and comment ({@code comment}) will be considered for
 * describing a resource. However, this can be changed with the parameter {@code properties}, which
 * is an JSON array of property IRIs.
 *
 * @author Kevin Haller
 * @version 1.0
 * @since 1.0
 */
@Lazy
@Component
@RegisterForExplorationFlow("esm.exploit.describe")
public class ResourceDescriber implements ExploitationOperator<DescriberPayload> {

  private static final Logger logger = LoggerFactory.getLogger(ResourceDescriber.class);

  private static final String DESCRIBER_QUERY = "SELECT ?s ${propertyVars} WHERE { \n"
      + "VALUES ?s {\n"
      + "  ${resourceList}\n"
      + "}\n"
      + "${properties}\n"
      + "}";

  private SPARQLService sparqlService;

  public ResourceDescriber(@Autowired SPARQLService sparqlService) {
    this.sparqlService = sparqlService;
  }

  @Override
  public Class<DescriberPayload> getParameterClass() {
    return DescriberPayload.class;
  }

  @Override
  public ExplorationContext apply(ExplorationContext context, DescriberPayload payload) {
    if (context instanceof IterableResourcesContext) {
      Map<String, String> valueMap = new HashMap<>();
      Set<Resource> resources = ((IterableResourcesContext) context).asResourceSet();
      valueMap.put("resourceList", resources.stream().map(
          BlankOrIRIJsonUtil::stringForSPARQLResourceOf).reduce("", (a, b) -> a + "\n" + b));
      Map<String, DescribePropertyPayload> properties = payload.getProperties();
      valueMap.put("propertyVars",
          properties.keySet().stream().map(p -> "?" + p).reduce("", (a, b) -> a + " " + b));
      valueMap.put("properties",
          properties.entrySet().stream().map(e -> String.format("OPTIONAL { ?s %s ?%s }",
              BlankOrIRIJsonUtil.stringForSPARQLResourceOf(e.getValue().getProperty()), e.getKey()))
              .reduce("", (a, b) -> a + "\n" + b));
      Table<Integer, String, RDFTerm> result = ((SelectQueryResult) sparqlService
          .query(new StrSubstitutor(valueMap).replace(DESCRIBER_QUERY), true)).value();
      for (Integer key : result.rowKeySet()) {
        Map<String, RDFTerm> row = result.row(key);
        ObjectNode resourceData = JsonNodeFactory.instance.objectNode();
        for (String prop : row.keySet()) {
          if (!"s".equals(prop)) {
            RDFTerm term = row.get(prop);
            if (term instanceof Literal) {
              Literal literal = (Literal) term;
              ObjectNode p = JsonNodeFactory.instance.objectNode();
              p.put("value", literal.getLexicalForm());
              p.put("language", literal.getLanguageTag().orElse(""));
              resourceData.set(prop, p);
            }
          }
        }
        context
            .putValuesData(((IRI) row.get("s")).getIRIString(), Collections.singletonList("describe"),
                resourceData);
      }
      return context;
    } else {
      throw new ExplorationFlowSpecificationException(
          "The given exploration flow is not valid, because a resource describer needs a context with an iterable collection of resources.");
    }
  }

}
