package at.ac.tuwien.ifs.es.middleware.service.exploration.operators.exploitation;

import at.ac.tuwien.ifs.es.middleware.kg.abstraction.rdf.RDFValueTerm;
import at.ac.tuwien.ifs.es.middleware.service.exploration.context.neighbourhood.Neighbourhood;
import at.ac.tuwien.ifs.es.middleware.service.exploration.context.result.RHood;
import at.ac.tuwien.ifs.es.middleware.kg.abstraction.rdf.Resource;
import at.ac.tuwien.ifs.es.middleware.kg.abstraction.sparql.SelectQueryResult;
import at.ac.tuwien.ifs.es.middleware.kg.abstraction.rdf.serializer.RDFTermJsonUtil;
import at.ac.tuwien.ifs.es.middleware.service.exploration.operators.payload.VoidPayload;
import at.ac.tuwien.ifs.es.middleware.service.exploration.RegisterForExplorationFlow;
import at.ac.tuwien.ifs.es.middleware.service.knowledgegraph.SPARQLService;
import com.fasterxml.jackson.core.JsonPointer;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.JsonNodeFactory;
import java.util.LinkedList;
import java.util.List;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.stream.Collectors;
import org.apache.commons.rdf.api.BlankNodeOrIRI;
import org.apache.commons.rdf.api.Literal;
import org.apache.commons.rdf.api.RDF;
import org.apache.commons.rdf.simple.SimpleRDF;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Component;

/**
 * @author Kevin Haller
 * @version 1.0
 * @since 1.0
 */
@Lazy
@Component
@RegisterForExplorationFlow(NeighbourhoodProvenance.OID)
public class NeighbourhoodProvenance implements
    ExploitationOperator<Neighbourhood, Neighbourhood, VoidPayload> {

  public static final String OID = "esm.exploit.neighbourhood.provenance";

  private static final String PROV_SPARQL_QUERY = "select ?id ?n where {\n"
      + "    VALUES (?s ?p ?o ?id) {\n"
      + "        %s\n"
      + "    }\n"
      + "    Graph ?n { ?s ?p ?o . }\n"
      + "}";

  private static final JsonPointer namespacesPath = JsonPointer.compile("/provenance/namespaces");

  private final SPARQLService sparqlService;

  @Autowired
  public NeighbourhoodProvenance(SPARQLService sparqlService) {
    this.sparqlService = sparqlService;
  }

  @Override
  public String getUID() {
    return OID;
  }

  @Override
  public Class<Neighbourhood> getExplorationContextInputClass() {
    return Neighbourhood.class;
  }

  @Override
  public Class<Neighbourhood> getExplorationContextOutputClass() {
    return Neighbourhood.class;
  }

  @Override
  public Class<VoidPayload> getPayloadClass() {
    return VoidPayload.class;
  }

  @Override
  public Neighbourhood apply(Neighbourhood context, VoidPayload payload) {
    /* collect statements */
    List<Statement> statementList = new LinkedList<>();
    context.streamOfResults().forEach(entry -> {
      RHood hood = entry.getRHood();
      for (Entry<Resource, List<RDFValueTerm>> pHood : hood.getProperties().entrySet()) {
        for (RDFValueTerm object : pHood.getValue()) {
          statementList.add(new Statement(entry.getSubject(), pHood.getKey(), object));
        }
      }
    });
    /* construct query */
    String query = String.format(PROV_SPARQL_QUERY,
        statementList.stream().map(Statement::toTuple).collect(Collectors.joining("\n")));
    /* compute and process query */
    sparqlService.<SelectQueryResult>query(query, true).value().stream().forEach((row) -> {
      String id = ((Literal) row.get("id")).getLexicalForm();
      Optional<JsonNode> provenanceNamespacesNodeOpt = context.values().get(id, namespacesPath);
      if (!provenanceNamespacesNodeOpt.isPresent()) {
        ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode();
        arrayNode.add(RDFTermJsonUtil.stringValue((BlankNodeOrIRI) row.get("n")));
        context.values().put(id, namespacesPath, arrayNode);
      } else {
        Optional<JsonNode> arrayNodeOpt = context.values().get(id, namespacesPath);
        arrayNodeOpt.ifPresent(jsonNode -> ((ArrayNode) jsonNode)
            .add(RDFTermJsonUtil.stringValue((BlankNodeOrIRI) row.get("n"))));
      }
    });
    return context;
  }

  private static class Statement {

    private static final RDF rdfFactory = new SimpleRDF();

    private Resource subject;
    private Resource predicate;
    private RDFValueTerm object;

    public Statement(Resource subject, Resource predicate, RDFValueTerm object) {
      this.subject = subject;
      this.predicate = predicate;
      this.object = object;
    }

    public String toTuple() {
      return String.format("(%s %s %s %s)", RDFTermJsonUtil.stringForSPARQLResourceOf(subject),
          RDFTermJsonUtil.stringForSPARQLResourceOf(predicate),
          RDFTermJsonUtil.stringForSPARQLRDFTermOf(object), rdfFactory.createLiteral(object.getId()));
    }

    @Override
    public String toString() {
      return "Statement{" +
          "subject=" + subject +
          ", predicate=" + predicate +
          ", object=" + object +
          '}';
    }
  }

}
